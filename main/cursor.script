local function screen_to_world(x, y, z, camera)
	local projection = go.get(camera, "projection")
	local view = go.get(camera, "view")
	local w, h = window.get_size()

	-- The window.get_size() function will return the scaled window size,
	-- ie taking into account display scaling (Retina screens on macOS for
	-- instance)
	-- We don't want the scaled window size when calculating screen to
	-- world coordinates so for now we do a hack here and assume all macOS
	-- screens are scaled 2x.
	-- We need a Lua API to get display scaling or an option on window.get_size()
	if sys.get_sys_info().system_name == "Darwin" then
		w = w / 2
		h = h / 2
	end

	-- https://defold.com/manuals/camera/#converting-mouse-to-world-coordinates
	local inv = vmath.inv(projection * view)
	x = (2 * x / w) - 1
	y = (2 * y / h) - 1
	z = (2 * z) - 1
	local x1 = x * inv.m00 + y * inv.m01 + z * inv.m02 + inv.m03
	local y1 = x * inv.m10 + y * inv.m11 + z * inv.m12 + inv.m13
	local z1 = x * inv.m20 + y * inv.m21 + z * inv.m22 + inv.m23
	return x1, y1, z1
end

function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	if not action_id or action_id == hash("touch") then
		-- convert mouse/touch screen position to world position
		local worldx, worldy = screen_to_world(action.x, action.y, 0, "player#camera")

		-- update cursor position to the world position of mouse/touch position
		local world = vmath.vector3(worldx, worldy, 1)
		go.set_position(world)

		-- set world position on label, rounded to two decimal points
		local text = ("x: %.2f y: %.2f"):format(worldx, worldy)
		label.set_text("#label", text)

		-- on click -> send world position to player
		if action.pressed then
			msg.post("player", "move_to", { to = world })
		end
	end
end
